#version 330 core

//Light Direction coming from the vertex shader
in vec3 lightDirV;
//Normal coming from the vertex shader
in vec3 vNormalV;
//halfvec coming from the vertex shader
in vec3 halfVec; 
//UV coming from the vertex shader
in vec2 UV; 

//Different colours
uniform vec3 lightColour	= {1,1,1};
uniform vec3 emissiveColour = {0,0,0};
uniform vec3 ambientColour  = {0.1f,0.1f,0.2f};
uniform vec3 diffuseColour  = {0.8f,0.1f,0.1f};
uniform vec3 specularColour = {0.0f,0.0f,0.0f};
//Up vector for calculations
uniform vec3 up 			= {0.0f,1.0f,0.0f};
//Shininess value
uniform float shininess     = 0.01f;
//alpha value
uniform float alpha         = 1.0f;

//rain1
uniform sampler2D textSampler0; 

//rain2
uniform sampler2D textSampler1; 

//rain3
uniform sampler2D textSampler2; 


//out put the colour
out vec4 colour;

void main(){
vec3 textureColour = texture2D(textSampler0,UV.xy).xyz;
vec3 textureColour2 = texture2D(textSampler1,UV.xy).xyz;
vec3 textureColour3 = texture2D(textSampler2,UV.xy).xyz;
float alpha,alpha2,alpha3;
///////////FIRST TEXTURE
if((textureColour.x  <= 0.1) && (textureColour.y <= 0.1) && (textureColour.z  <= 0.1)){
alpha = 0.0f;
}
else
{
alpha = 0.1f;
}
vec4 temp_rain = vec4(textureColour.x,textureColour.y,textureColour.z,alpha);
///////////second TEXTURE
if((textureColour2.x  <= 0.1) && (textureColour2.y <= 0.1) && (textureColour2.z  <= 0.1)){
alpha2 = 0.0f;
}
else
{
alpha2 = 0.1f;
}
vec4 temp_rain2 = vec4(textureColour2.x,textureColour2.y,textureColour2.z,alpha2);
///////////third TEXTURE
if((textureColour3.x  <= 0.1) && (textureColour3.y <= 0.1) && (textureColour3.z  <= 0.1)){
alpha3 = 0.0f;
}
else
{
alpha3 = 0.1f;
}
vec4 temp_rain3 = vec4(textureColour3.x,textureColour3.y,textureColour3.z,alpha3);
colour = temp_rain + temp_rain2 + temp_rain3;
//vec3 TextureNormal = normalize(texture2D(textSampler1, UV).rgb*2.0 - 1.0);
//vec3 diffuse = textureColour * max( dot( TextureNormal, lightDirV ), 0);
//vec3 specular= textureColour * dot( TextureNormal, lightDirV ) * max( dot( TextureNormal, halfVec ), 0) * shininess;
//vec3 temp = diffuse + specular + emissiveColour + ambientColour;
//vec4 temp_rain = vec4(temp.x,temp.y,temp.z,alpha);

///////////////SECOND TEXTURE
//if((textureColour2.x  <= 0.15) && (textureColour2.y <= 0.15) && (textureColour2.z  <= 0.15)){
//alpha2 = 0.0f;
//}
//else
//{
//alpha2 = 0.1f;
//}
//
//vec3 TextureNormal2 = normalize(texture2D(textSampler3, UV).rgb*2.0 - 1.0);
//vec3 diffuse2 = textureColour2 * max( dot( TextureNormal2, lightDirV ), 0);
//vec3 specular2 = textureColour2 * dot( TextureNormal2, lightDirV ) * max( dot( TextureNormal2, halfVec ), 0) * shininess;
//vec3 temp2 = diffuse2 + specular2 + emissiveColour + ambientColour;
//vec4 temp_rain2 = vec4(temp2.x,temp2.y,temp2.z,alpha2);
//
/////////////THIRD TEXTURE
//if((textureColour3.x  <= 0.15) && (textureColour3.y <= 0.15) && (textureColour3.z  <= 0.15)){
//alpha3 = 0.0f;
//}
//else
//{
//alpha3 = 0.3f;
//}
//
//vec3 TextureNormal3 = normalize(texture2D(textSampler5, UV).rgb*2.0 - 1.0);
//vec3 diffuse3 = textureColour3 * max( dot( TextureNormal3, lightDirV ), 0);
//vec3 specular3 = textureColour3 * dot( TextureNormal3, lightDirV ) * max( dot( TextureNormal3, halfVec ), 0) * shininess;
//vec3 temp3 = diffuse3 + specular3 + emissiveColour + ambientColour;
//vec4 temp_rain3 = vec4(temp3.x,temp3.y,temp3.z,alpha3);

}