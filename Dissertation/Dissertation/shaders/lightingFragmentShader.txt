#version 430 core

//must be known before compile time.
#define no_of_lights 5

//uniform block coming from program
layout (std140) uniform PointLights{
	vec4 PLposition[no_of_lights];
	vec4 PLambient[no_of_lights];
	vec4 PLlightColour[no_of_lights];
	float PLconstant[no_of_lights];
	float PLliniear[no_of_lights];
	float PLquadratic[no_of_lights];
	bool PLactive[no_of_lights];
	mat4 PLShadowProjection[6][no_of_lights];
};

//struct PL{
//	vec4 PLposition;
//	vec4 PLambient;
//	vec4 PLlightColour;
//	float PLconstant;
//	float PLliniear;
//	float PLquadratic;
//};
//
//layout (std140) uniform PointLights{
//	PL pointLight[no_of_lights];
//};
layout (std140) uniform DirectionalLights{
vec4 DLdirection;
vec4 DLlightColour;
vec4 DLambient;
};
//Light Direction for point light coming from the vertex shader
in vec3 lightDirPLV[no_of_lights];

in vec3 lightDirDLV;
//Normal coming from the vertex shader
in vec3 vNormalV;
//halfvec coming from the vertex shader
in vec3 halfVecPL[no_of_lights]; 
in vec3 halfVecDL;
//UV coming from the vertex shader
in vec2 UV; 
//positiong coming from vertex shader
in vec4 vPositionV;

in vec4 FragPositionLightSpace;

//Shininess value
uniform float shininess     = 0.5f;
//Texture
uniform sampler2D textSampler0; 
//Texture Normal
uniform sampler2D textSampler1;

uniform sampler2D shadowMap;

uniform samplerCube depthMap;
float shadow;
float PLshadow;
layout (location = 0) out vec4 colour;
layout (location = 1) out vec4 brightness;

vec3 calculatePointLights(vec3 lightDirection, vec4 lightColour, float cons, float lin, float quad, vec3 halfvec, vec4 ambient, vec4 lightPosition);
vec3 calculateDirectionalLight(vec4 lightColour,vec4 ambient ,vec3 lightDirection, vec3 halfvec, float shad);
float calculateShadows(vec4 lightSpaceFragPosition);
float calculatePointLightShadows(vec4 fragPosition, vec4 lightPosition);

void main(){
	vec3 result;
//if((PLShadowProjection[0][0])[2][0] > 0){
	shadow = calculateShadows(FragPositionLightSpace);
	PLshadow = calculatePointLightShadows(vPositionV, PLposition[0]);
//}
	
	result = calculateDirectionalLight(DLlightColour,DLambient,lightDirDLV,halfVecDL, shadow);
	
	
		for(int i = 0; i<no_of_lights; i++)
		{
			if(PLactive[i] == true)
			{
				result += calculatePointLights(lightDirPLV[i], PLlightColour[i],PLconstant[i],PLliniear[i],PLquadratic[i],halfVecPL[i],PLambient[i], PLposition[i]);
			}
		}
	//result  = result + (1.0 - shadow);
	
	colour = vec4(result.x,result.y,result.z, 1.0f);
	//colour = vec4(PLShadowProjection[3][2][3].xyz, 1.0); //Check to see if the shadow projections are coming through. 
	float tempBreach = dot(colour.xyz, vec3(0.2126,0.7152,0.0722));
	if(tempBreach > 1.0){
		brightness = vec4(colour.xyz,1.0);
	}
}
vec3 calculateDirectionalLight(vec4 lightColour,vec4 ambient ,vec3 lightDirection, vec3 halfvec, float shad){
    lightDirection = normalize(lightDirection);
	vec3 temp;
	//Give me the normalised textures
	vec3 TextureNormal = normalize(texture2D(textSampler1, UV).rgb*2.0 - 1.0);
	vec3 diffuse = texture(textSampler0, UV).rgb * lightColour.xyz * max( dot( TextureNormal, lightDirection), 0);
	vec3 specular = texture(textSampler0, UV ).rgb * lightColour.xyz  * dot( TextureNormal, lightDirection ) * max( dot( TextureNormal, halfvec ), 0) * shininess;
	temp = (diffuse + specular) * (ambient.xyz + (1.0 - shad)) ;
	return temp;
}
vec3 calculatePointLights(vec3 lightDirection, vec4 lightColour, float cons, float lin, float quad, vec3 halfvec, vec4 ambient, vec4 lightPosition){
    lightDirection = normalize(lightDirection);
	vec3 temp;
	//Give me the normalised textures
	vec3 TextureNormal = normalize(texture2D(textSampler1, UV).rgb*2.0 - 1.0);
	vec3 diffuse 	= texture(textSampler0, UV).rgb * lightColour.xyz * max( dot( TextureNormal, lightDirection ), 0);
	vec3 specular 	= texture(textSampler0, UV ).rgb * lightColour.xyz  * dot( TextureNormal, lightDirection ) * max( dot( TextureNormal, halfvec ), 0) * shininess;
	float distance    = length(lightPosition - vPositionV);
	float attenuation = 1.0f / (cons + lin * distance + quad * (distance * distance));
	if(attenuation > 1.0f){
		attenuation = 1.0f;
	}	
	
	temp = (diffuse + specular) * (ambient.xyz + (1.0 - shadow)) ;
	temp *= attenuation;	
	return temp;
}

float calculateShadows(vec4 lightSpaceFragPosition){
	vec3 projCoords = lightSpaceFragPosition.xyz / lightSpaceFragPosition.w;
	projCoords = projCoords * 0.5 + 0.5;
	//float bias = 0.005;
	vec3 normal = normalize(vNormalV);
	float bias = max(0.05 * (1.0 - dot(normal, DLdirection.xyz)), 0.005);  
	//float bias = max(0.05 * (1.0 - dot(normal, lightDirDLV.xyz)), 0.005);  
    // Transform to [0,1] range
    
    // Get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    // Get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    // Check whether current frag pos is in shadow
	float DLshadow;
	vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
	for(int x = -1; x <= 1; ++x)
	{
		for(int y = -1; y <= 1; ++y)
		{
			float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
			DLshadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
		}    
	}
	
	DLshadow /= 9.0;
	
    if(projCoords.z > 1.0){
        DLshadow = 0.0;
	}
	
    return DLshadow;
}
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1), 
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0),
   vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
   vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1)
);
float calculatePointLightShadows(vec4 fragPosition, vec4 lightPosition)
{
	float PLTshadow;
	vec3 fragToLight = fragPosition.xyz - lightPosition.xyz;
	float closestDepth = texture(depthMap,fragToLight).r;
	//closestDepth *= 25.0f;	
	float bias = 0.15;
	float currentDepth = length(fragToLight);
	int samples = 20;
    float viewDistance = length(vec4(6.0f,6.0f,6.0f,1.0f) - fragPosition);
    float diskRadius = (1.0 + (viewDistance / 25.0f)) / 25.0;
    for(int i = 0; i < samples; ++i)
    {
        float closestDepth = texture(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= 25.0f;   // Undo mapping [0;1]
        if(currentDepth - bias > closestDepth)
            PLTshadow += 1.0;
    }
    PLTshadow /= float(samples);
	
	return PLTshadow;
}