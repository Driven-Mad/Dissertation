#version 330 core

//Vertex position coming from the program
layout(location = 0) in vec4 vPosition;
//Normal coming from the program
layout(location = 1) in vec3 vNormalIn;
//UVS coming from the program
layout(location = 2) in vec2 vUVIn; 
//Tangents coming from the program
layout(location = 3) in vec3 vTangentIn;
//BiTangents coming from the program
layout(location = 4) in vec3 vBiTangentIn;

//model matrix coming from the program
uniform mat4 modelMat;
//view matrix coming from the program
uniform mat4 viewMat;
//projection matrix coming from the program
uniform mat4 projMat;
//model 3X3 matrix coming from the program
uniform mat3 MV3x3;
//UP value
uniform vec3 up = {0.0f,1.0f,0.0f};
//Worldspace Light Position
uniform vec4 worldSpaceLightPos = {1,0.8,1,1};

//outputs to the fragment shader, the Normal
out vec3 vNormalV;
//outputs to the fragment shader, the Light Direction
out vec3 lightDirV;
//outputs to the fragment shader, the half Vector
out vec3 halfVec;
//outputs to the fragment shader, the UV
out vec2 UV;

void main(){
//switch everything to tangent space.
vec4 eyeSpaceVertPos;
vec3 vertexNormal_cameraspace = MV3x3 * normalize(vNormalIn);
vec3 vertexTangent_cameraspace = MV3x3 * normalize(vTangentIn);
vec3 vertexBitangent_cameraspace = MV3x3 * normalize(vBiTangentIn);

mat3 TBN = transpose(mat3(vertexTangent_cameraspace,vertexBitangent_cameraspace,vertexNormal_cameraspace));
vNormalV = MV3x3 * vNormalIn;

//checks if the normal is facing up to add a deformation to it so to apply a "depth" for snow.

//do a dot product between the normal in tangent space and the up value, then take the result, if it's greater than
//0 then we know the normal is facing up.
float dotresult = dot(vertexNormal_cameraspace,up);
if( dotresult > 0.0f){
	vec4 modifiedPos = vec4(0.0f,dotresult/50.0f,0.0f,0.0f) + (modelMat * vPosition);
	gl_Position = projMat * viewMat * modifiedPos;
	eyeSpaceVertPos = viewMat * modifiedPos;
}
else{
	gl_Position = projMat * viewMat * modelMat * vPosition;
	eyeSpaceVertPos = viewMat * modelMat * vPosition;
}

//Create the different attributes for light calculations and colour to send to the fragment shader.
vec4 eyeSpaceLightPos = viewMat * worldSpaceLightPos;
lightDirV = TBN * normalize( vec3(eyeSpaceLightPos) - vec3(eyeSpaceVertPos) );
vec3 eyeDir = TBN * -eyeSpaceVertPos.xyz;
halfVec = normalize( normalize(eyeDir) + normalize(lightDirV));
UV = vUVIn;
}